# 
# Generate a sitemap for NASA's Generic Kernel URL! 
# This requires the program `lynx` to be installed.
# 

using TOML
using HTTP
using Dates
using JSON3
using SPICEKernels
using IOCapture
using FLoops
using Distributed
using SPICEApplications: brief, ckbrief, dskbrief, commnt

"""
Traverse a JSON array for file paths.
"""
function traverse(items::AbstractArray)
    kernels = Set{String}()

    for item in items
        parent = item["parent"]
        filename = item["filename"]
        if startswith(parent, "./naif") &&
           any(ext -> endswith(filename, ext), keys(SPICEKernels.SPICE_EXTENSIONS))
            push!(
                kernels,
                replace(
                    joinpath(item["parent"], item["filename"]),
                    "./naif" => SPICEKernels.NAIF_KERNELS_URL,
                ),
            )
        end
    end

    return kernels
end

"""
Write all current kernel paths to the provided file name.
"""
function code!(kernels; project = nothing, download = nothing, document = nothing)
    kernellist = collect(kernels)
    sort!(kernellist)

    # oldkernels = collect(values(SPICEKernels.NAIF_KERNELS_URL))
    # difference = setdiff(kernellist, oldkernels)
    # if isempty(difference)
    #     @info "No changes to generic kernel paths."
    #     if !force
    #         return nothing
    #     end
    # elseif !force
    #     changes = join(", ", difference)
    #     @info "The following kernel names been added or removed: $changes."
    # end

    if isnothing(project)
        subdir(path) = split(replace(path, SPICEKernels.NAIF_KERNELS_URL => ""), "/")[2]
        subdirs = unique(subdir.(kernellist))
        @assert allunique(subdirs)

        projects = Dict(
            dir => filter(path -> subdir(path) == dir, collect(kernellist)) for
            dir in subdirs
        )

        names = collect(keys(projects))
        sort!(names; by = name -> length(projects[name]), rev = true)

        Threads.@threads for name in names
            code!(deepcopy(projects[name]), project = deepcopy(name))
        end

        dirpath = abspath(joinpath(@__DIR__, "..", "src", "gen"))
        isdir(dirpath) || mkdir(dirpath)

        open(joinpath(dirpath, "projects.jl"), "w") do file
            write(
                file,
                "#\n# This is an autogenerated file! See gen/make.jl for more information.\n#\n\n",
            )
            for name in collect(keys(projects))
                write(file, """include("$(lowercase(name))/$(titlecase(name)).jl")\n""")
            end
        end

        project = TOML.parsefile(joinpath(@__DIR__, "..", "Project.toml"))
        version = let version = project["version"]
            @eval @v_str $version
        end

        major = version.major
        minor = version.minor
        patch = version.patch + 1

        project["version"] = "$major.$minor.$patch"

        open(joinpath(@__DIR__, "..", "Project.toml"), "w") do file
            TOML.print(file, project)
        end

        @info "SPICEKernels version bumped to $major.$minor.$patch."
    else
        dirpath = abspath(joinpath(@__DIR__, "..", "src", "gen", lowercase(project)))
        isdir(dirpath) || mkdir(dirpath)

        mappath = joinpath(dirpath, "map.jl")

        name = uppercase(replace(project, "_kernels" => ""))

        open(mappath, "w") do file
            write(
                file,
                "#\n# This is an autogenerated file! See gen/make.jl for more information.\n#\n\n",
            )
            write(
                file,
                """\"\"\"\n$name kernels hosted by naif.jpl.nasa.gov as of $(today()). [1]\n\n# Extended Help\n\n## References\n\n[1] https://naif.jpl.nasa.gov/pub/naif/$project/\n\"\"\"\n""",
            )
            write(file, "const $(name)_KERNELS = Base.ImmutableDict(\n")
            for kernel in kernellist
                write(file, """    "$(basename(kernel))" => "$kernel",\n""")
            end
            write(file, ")\n\n")
        end

        kernelpath = joinpath(dirpath, "kernels.jl")

        function sanitize(name::AbstractString)
            split(replace(name, "-" => "_"), ".") |> first |> String
        end
        function implement(name::AbstractString)
            let
                T = SPICEKernels.type(name)
                M = Base.ImmutableDict(
                    SPICEKernels.EphemerisKernel => SPICEKernels.SPK,
                    SPICEKernels.DigitalShapeKernel => SPICEKernels.DSK,
                    SPICEKernels.PlanetaryConstantsKernel => SPICEKernels.PCK,
                    SPICEKernels.FramesKernel => SPICEKernels.FK,
                    SPICEKernels.LeapSecondsKernel => SPICEKernels.LSK,
                )

                M[T]
            end
        end

        size(file::AbstractString) =
            let
                bytes = filesize(file)

                KB = 1024
                MB = KB^2
                GB = KB^3
                if bytes >= GB
                    return "$(round(bytes / GB, digits=1)) GB"
                elseif bytes >= MB
                    return "$(round(bytes / MB, digits=1)) MB"
                else
                    return "$(round(bytes / KB, digits=1)) KB"
                end
            end

        function description(path::AbstractString)
            let
                extension = last(splitext(path))

                if extension in (".bsp", ".bpc")
                    desc = IOCapture.capture() do
                        try
                            brief(path)
                        catch
                            println(
                                "\nAn error occurred when parsing this kernel with `brief`.",
                            )
                        end
                    end
                elseif extension == ".tsp"
                    desc = IOCapture.capture() do
                        try
                            ckbrief(path)
                        catch
                            println(
                                "\nAn error occurred when parsing this kernel with `ckbrief`.",
                            )
                        end
                    end
                elseif extension in (".dsk", ".bds")
                    desc = IOCapture.capture() do
                        try
                            dskbrief(path)
                        catch
                            println(
                                "\nAn error occurred when parsing this kernel with `dskbrief`.",
                            )
                        end
                    end
                else
                    @debug "The \"$extension\" extension is not yet supported."
                    desc = "A `$(SPICEKernels.type(path))`. If the kernel type is not binary, open the file for more information!"
                end

                desc = desc isa String ? desc : convert(String, desc.output)

                return replace(desc, joinpath(SPICEKernels.SPICE_KERNEL_DIR, "") => "")
            end
        end

        toexport = String[]
        open(kernelpath, "w") do file
            write(
                file,
                "#\n# This is an autogenerated file! See gen/make.jl for more information.\n#\n\n",
            )
            for kernel in kernellist
                if !occursin("old_versions", kernel) && !endswith(kernel, ".pc")
                    if occursin("generic_kernels", kernel)
                        local path
                        try
                            path = SPICEKernels.fetchkernel(kernel, ignorecache = true)
                        catch e
                            @error "failed to fetch $kernel: \"$e\""
                            continue
                        end

                        name = sanitize(basename(kernel))
                        type = implement(kernel)

                        if count(k -> sanitize(basename(k)) == name, kernellist) > 1
                            name = name * "_" * lowercase(last(split(string(type), ".")))
                        end

                        push!(toexport, name)

                        write(
                            file,
                            """\n\"\"\"\nA $type kernel of size $(size(path)), linked from https://naif.jpl.nasa.gov [1].\nCalling this variable like a function will return a path to the file, downloading \nto scratchspace if necessary.\n\n# Extended Help\n\nThis kernel's link was sourced on $(today()).\n\n## References\n\n[1] $kernel\n\n## Description\n\n```\n$(description(path))\n```\n\"\"\"\n""",
                        )
                        if "$kernel.pc" in kernellist
                            write(
                                file,
                                """const $name = $type(!Sys.iswindows() ? "$kernel" : "$kernel.pc")\n""",
                            )
                        else
                            write(file, """const $name = $type("$kernel")\n""")
                        end

                        rm(path)
                    else
                        name = sanitize(basename(kernel))
                        type = implement(kernel)

                        if count(k -> sanitize(basename(k)) == name, kernellist) > 1
                            name = name * "_" * lowercase(last(split(string(type), ".")))
                        end

                        push!(toexport, name)

                        write(
                            file,
                            """\n\"\"\"\nA $type kernel linked from https://naif.jpl.nasa.gov [1].\nCalling this variable like a function will return a path to the file, downloading \nto scratchspace if necessary.\n\n# Extended Help\n\nThis kernel's link was sourced on $(today()).\n\n## References\n\n[1] $kernel\n\"\"\"\n""",
                        )
                        if "$kernel.pc" in kernellist
                            write(
                                file,
                                """const $name = $type(!Sys.iswindows() ? "$kernel" : "$kernel.pc")\n""",
                            )
                        else
                            write(file, """const $name = $type("$kernel")\n""")
                        end
                    end
                end
            end
            write(file, "\nexport\n    ")
            write(file, join(toexport, ",\n    "))
        end

        modpath = joinpath(dirpath, titlecase(project) * ".jl")
        open(modpath, "w") do file
            write(
                file,
                "#\n# This is an autogenerated file! See gen/make.jl for more information.\n#\n\n",
            )

            write(
                file,
                """\n\"\"\"\nAll $name kernels, linked from https://naif.jpl.nasa.gov.\n\"\"\"\n""",
            )

            if project == "generic_kernels"
                write(file, "module Generic\n")
            else
                write(file, "module $(titlecase(project))\n")
            end

            write(file, """include("map.jl")\n""")
            write(file, """include("kernels.jl")\n""")
            write(file, "end # module\n")
        end
    end

    return nothing
end

# 
# The script portion!
# 

sitemap = JSON3.read("ls-lR.json")
kernels = traverse(sitemap)
code!(kernels)
